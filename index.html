<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smartwatch Heart Rate Monitor</title>
    <!-- Using Tailwind CSS for a modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and minor style adjustments */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Style for the debug log */
        #debug {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .recent-hr {
            animation: highlight 1s ease-out;
        }
        @keyframes highlight {
            from { background-color: #4ade80; }
            to { background-color: transparent; }
        }
    </style>
</head>
<body class="antialiased text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Smartwatch Heart Rate Monitor</h1>
            <p class="text-lg text-gray-600 mt-2">Connect your Bluetooth heart rate device.</p>
        </header>

        <!-- Main controls -->
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-6 text-center">
            <button id="connectBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">
                Connect to Device
            </button>
            <p id="status" class="text-gray-500 mt-4 text-sm">Status: Disconnected</p>
        </div>

        <!-- Heart Rate Data Display -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Current Heart Rate</p>
                <p id="hrDisplay" class="text-6xl font-bold text-red-500">--</p>
                <p class="text-lg text-gray-500">bpm</p>
            </div>
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Min / Max</p>
                <p class="text-4xl font-semibold"><span id="minHr">--</span> / <span id="maxHr">--</span></p>
                <p class="text-lg text-gray-500 mt-2">Lowest / Highest</p>
            </div>
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Smoothed Average</p>
                <p id="avgHr" class="text-4xl font-semibold">--</p>
                <p class="text-lg text-gray-500 mt-2">Recent Trend</p>
            </div>
        </div>
        
        <!-- Recent Readings -->
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-6">
             <h3 class="font-semibold text-lg mb-2">Recent Readings</h3>
             <p id="hrHistory" class="text-gray-600 text-lg">--</p>
        </div>

        <!-- Debugging and Service Discovery -->
        <div class="bg-white p-6 rounded-2xl shadow-lg">
            <h3 class="font-semibold text-lg mb-3">Developer Log & Discovered Services</h3>
            <p class="text-sm text-gray-600 mb-4">
                If heart rate doesn't appear, connect your device and watch this log. It will show all data received from your watch. Look for a pattern in the numbers that matches your heart rate.
            </p>
            <div id="debug" class="bg-gray-900 text-green-400 p-4 rounded-lg h-64 overflow-y-auto">
                [Ready] Waiting for connection...
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const hrDisplay = document.getElementById('hrDisplay');
        const minHrEl = document.getElementById('minHr');
        const maxHrEl = document.getElementById('maxHr');
        const avgHrEl = document.getElementById('avgHr');
        const hrHistoryEl = document.getElementById('hrHistory');
        const debugLog = document.getElementById('debug');

        // State variables
        let bluetoothDevice = null;
        let hrValues = [];
        let minHr = Infinity;
        let maxHr = -Infinity;
        let smoothedHr = 0; // Using an Exponential Moving Average (EMA)

        /**
         * Logs messages to the debug console on the webpage.
         * @param {string} message - The message to log.
         * @param {string} type - 'info', 'error', 'success', 'data'.
         */
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colorMap = {
                'info': 'text-gray-400',
                'error': 'text-red-500 font-semibold',
                'success': 'text-green-400 font-semibold',
                'data': 'text-cyan-400'
            };
            debugLog.innerHTML += `<div class="${colorMap[type]}">[${timestamp}] ${message}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        /**
         * Handles the connection process to the Bluetooth device.
         */
        connectBtn.addEventListener('click', async () => {
            try {
                log('Requesting Bluetooth device...');
                statusEl.textContent = 'Status: Searching...';
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    // **UPDATED:** Requesting specific proprietary services increases our chances
                    // of finding the correct one for the BOAT LEAP CALL.
                    optionalServices: [
                        'heart_rate', // Standard Heart Rate Service
                        '0000180d-0000-1000-8000-00805f9b34fb', // Full UUID for Heart Rate
                        '0000fee0-0000-1000-8000-00805f9b34fb', // Common Xiaomi/Huami
                        '0000aaa0-0000-1000-8000-aabbccddeeff', // From your screenshot
                    ]
                });

                log(`Connecting to ${bluetoothDevice.name || 'Unnamed Device'}...`, 'success');
                statusEl.textContent = `Status: Connecting to ${bluetoothDevice.name}...`;
                
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                const server = await bluetoothDevice.gatt.connect();
                log('GATT Server connected. Discovering services...', 'success');
                statusEl.textContent = 'Status: Discovering Services...';

                await findAllServicesAndCharacteristics(server);

            } catch (error) {
                log(`Connection failed: ${error}`, 'error');
                statusEl.textContent = `Status: Error - ${error.message}`;
            }
        });
        
        /**
         * Cleans up when the device disconnects.
         */
        function onDisconnected() {
            log('Device disconnected.', 'error');
            statusEl.textContent = 'Status: Disconnected';
            bluetoothDevice = null;
            // Reset UI
            hrDisplay.textContent = '--';
            minHrEl.textContent = '--';
            maxHrEl.textContent = '--';
            avgHrEl.textContent = '--';
            hrHistoryEl.textContent = '--';
        }

        /**
         * **UPDATED:** This function now discovers ALL services and characteristics,
         * logging their properties and subscribing to any that can notify or indicate.
         * @param {BluetoothRemoteGATTServer} server - The GATT server instance.
         */
        async function findAllServicesAndCharacteristics(server) {
            try {
                log('Searching all services...');
                const allServices = await server.getPrimaryServices();
                log(`Found ${allServices.length} services. Inspecting them...`);

                for (const service of allServices) {
                    log(`Inspecting Service: ${service.uuid}`);
                    try {
                        const characteristics = await service.getCharacteristics();
                        if (characteristics.length === 0) {
                            log(`  -> Service has no characteristics.`, 'info');
                            continue;
                        }
                        log(`  -> Found ${characteristics.length} characteristics.`);

                        for (const char of characteristics) {
                            // Build properties string for detailed logging
                            const props = [];
                            if (char.properties.read) props.push('READ');
                            if (char.properties.write) props.push('WRITE');
                            if (char.properties.writeWithoutResponse) props.push('WRITE_NO_RESPONSE');
                            if (char.properties.notify) props.push('NOTIFY');
                            if (char.properties.indicate) props.push('INDICATE');
                            log(`  - Char: ${char.uuid} [Properties: ${props.join(', ')}]`);

                            // Subscribe to any characteristic that can send data updates.
                            if (char.properties.notify || char.properties.indicate) {
                                log(`    Found NOTIFY/INDICATE property. Subscribing for data...`, 'success');
                                await startHrNotifications(char);
                            }
                        }
                    } catch (error) {
                        log(`  -> Error getting characteristics for this service: ${error.message}`, 'error');
                    }
                }
                log('Finished searching all services. Waiting for data...');
                statusEl.textContent = 'Status: Connected & Listening';

            } catch (error) {
                log(`Error finding services: ${error}`, 'error');
                statusEl.textContent = `Status: Error - ${error.message}`;
            }
        }

        /**
         * Starts notifications for a given characteristic and attaches the event listener.
         * @param {BluetoothRemoteGATTCharacteristic} characteristic
         */
        async function startHrNotifications(characteristic) {
            try {
                characteristic.addEventListener('characteristicvaluechanged', handleHeartRateData);
                await characteristic.startNotifications();
                log(`Started listening to notifications from ${characteristic.uuid}`, 'success');
            } catch (error) {
                log(`Failed to start notifications on ${characteristic.uuid}: ${error.message}`, 'error');
            }
        }

        /**
         * This function is called every time the watch sends data.
         * It tries to parse the heart rate from the raw data.
         * @param {Event} event - The event object from the characteristic.
         */
        function handleHeartRateData(event) {
            const characteristic = event.target;
            const value = characteristic.value;
            const rawData = new Uint8Array(value.buffer);
            
            log(`Data from [${characteristic.uuid}]: [${rawData.join(', ')}]`, 'data');

            let heartRate = parseHeartRate(value);

            if (heartRate !== null) {
                log(`Successfully parsed Heart Rate: ${heartRate} bpm`, 'success');
                
                hrDisplay.textContent = heartRate;
                hrDisplay.classList.add('recent-hr');
                hrDisplay.addEventListener('animationend', () => {
                    hrDisplay.classList.remove('recent-hr');
                }, { once: true });

                hrValues.push(heartRate);
                if (hrValues.length > 20) {
                    hrValues.shift();
                }

                minHr = Math.min(...hrValues);
                maxHr = Math.max(...hrValues);

                if (smoothedHr === 0) {
                    smoothedHr = heartRate;
                } else {
                    smoothedHr = (heartRate * 0.2) + (smoothedHr * 0.8);
                }

                minHrEl.textContent = minHr;
                maxHrEl.textContent = maxHr;
                avgHrEl.textContent = smoothedHr.toFixed(1);
                hrHistoryEl.textContent = hrValues.slice(-10).join(', ');
            }
        }
        
        /**
         * Tries various methods to parse the heart rate from a DataView object.
         * @param {DataView} value - The data from the Bluetooth characteristic.
         * @returns {number|null} The parsed heart rate or null if not found.
         */
        function parseHeartRate(value) {
            const rawData = new Uint8Array(value.buffer);
            
            // Standard Bluetooth Heart Rate Profile (Flags in first byte)
            const flags = value.getUint8(0);
            if ((flags & 0x01) === 0) { // 8-bit heart rate
                let hr = value.getUint8(1);
                if (hr > 30 && hr < 230) return hr;
            } else { // 16-bit heart rate
                let hr = value.getUint16(1, true); // true for little-endian
                if (hr > 30 && hr < 230) return hr;
            }

            // --- Fallback for Proprietary Formats ---
            // Many devices send HR in the second byte of a longer array without flags.
            if (rawData.length > 1) {
                let hr = rawData[1];
                if (hr > 30 && hr < 230) {
                    log(`(Fallback) Found potential HR at byte 1: ${hr}`);
                    return hr;
                }
            }
            
            // Another common pattern is the third byte
            if (rawData.length > 2) {
                let hr = rawData[2];
                if (hr > 30 && hr < 230) {
                    log(`(Fallback) Found potential HR at byte 2: ${hr}`);
                    return hr;
                }
            }

            return null;
        }

    </script>
</body>
</html>
