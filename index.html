<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smartwatch Heart Rate Monitor</title>
    <!-- Using Tailwind CSS for a modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and minor style adjustments */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Style for the debug log */
        #debug {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .recent-hr {
            animation: highlight 1s ease-out;
        }
        @keyframes highlight {
            from { background-color: #4ade80; }
            to { background-color: transparent; }
        }
    </style>
</head>
<body class="antialiased text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Smartwatch Heart Rate Monitor</h1>
            <p class="text-lg text-gray-600 mt-2">Connect your Bluetooth heart rate device.</p>
        </header>

        <!-- Main controls -->
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-6 text-center">
            <button id="connectBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">
                Connect to Device
            </button>
            <p id="status" class="text-gray-500 mt-4 text-sm">Status: Disconnected</p>
        </div>

        <!-- Heart Rate Data Display -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Current Heart Rate</p>
                <p id="hrDisplay" class="text-6xl font-bold text-red-500">--</p>
                <p class="text-lg text-gray-500">bpm</p>
            </div>
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Min / Max</p>
                <p class="text-4xl font-semibold"><span id="minHr">--</span> / <span id="maxHr">--</span></p>
                <p class="text-lg text-gray-500 mt-2">Lowest / Highest</p>
            </div>
            <div class="bg-white p-6 rounded-2xl shadow-lg text-center">
                <p class="text-lg text-gray-500 mb-2">Smoothed Average</p>
                <p id="avgHr" class="text-4xl font-semibold">--</p>
                <p class="text-lg text-gray-500 mt-2">Recent Trend</p>
            </div>
        </div>
        
        <!-- Recent Readings -->
        <div class="bg-white p-6 rounded-2xl shadow-lg mb-6">
             <h3 class="font-semibold text-lg mb-2">Recent Readings</h3>
             <p id="hrHistory" class="text-gray-600 text-lg">--</p>
        </div>

        <!-- Debugging and Service Discovery -->
        <div class="bg-white p-6 rounded-2xl shadow-lg">
            <h3 class="font-semibold text-lg mb-3">Developer Log & Discovered Services</h3>
            <p class="text-sm text-gray-600 mb-4">
                If heart rate doesn't appear, connect your device and watch this log. It will show all data received from your watch. Look for a pattern in the numbers that matches your heart rate.
            </p>
            <div id="debug" class="bg-gray-900 text-green-400 p-4 rounded-lg h-64 overflow-y-auto">
                [Ready] Waiting for connection...
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const hrDisplay = document.getElementById('hrDisplay');
        const minHrEl = document.getElementById('minHr');
        const maxHrEl = document.getElementById('maxHr');
        const avgHrEl = document.getElementById('avgHr');
        const hrHistoryEl = document.getElementById('hrHistory');
        const debugLog = document.getElementById('debug');

        // State variables
        let bluetoothDevice = null;
        let hrCharacteristic = null;
        let hrValues = [];
        let minHr = Infinity;
        let maxHr = -Infinity;
        let smoothedHr = 0; // Using an Exponential Moving Average (EMA)

        /**
         * Logs messages to the debug console on the webpage.
         * @param {string} message - The message to log.
         * @param {string} type - 'info', 'error', 'success', 'data'.
         */
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colorMap = {
                'info': 'text-gray-400',
                'error': 'text-red-500 font-semibold',
                'success': 'text-green-400 font-semibold',
                'data': 'text-cyan-400'
            };
            debugLog.innerHTML += `<div class="${colorMap[type]}">[${timestamp}] ${message}</div>`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        /**
         * Handles the connection process to the Bluetooth device.
         */
        connectBtn.addEventListener('click', async () => {
            try {
                log('Requesting Bluetooth device...');
                statusEl.textContent = 'Status: Searching...';
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    // Using acceptAllDevices is crucial for non-standard devices like many watches.
                    acceptAllDevices: true,
                    // We still list optionalServices to hint what we're looking for.
                    optionalServices: [
                        'heart_rate', // Standard Heart Rate Service
                        '0000180d-0000-1000-8000-00805f9b34fb', // Full UUID for Heart Rate
                        // Add other known proprietary service UUIDs here if you find them
                        '0000fee0-0000-1000-8000-00805f9b34fb', // Common Xiaomi/Huami
                    ]
                });

                log(`Connecting to ${bluetoothDevice.name || 'Unnamed Device'}...`, 'success');
                statusEl.textContent = `Status: Connecting to ${bluetoothDevice.name}...`;
                
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                const server = await bluetoothDevice.gatt.connect();
                log('GATT Server connected. Discovering services...', 'success');
                statusEl.textContent = 'Status: Discovering Services...';

                // This is the key part: find the heart rate service and characteristic
                await findHeartRateService(server);

            } catch (error) {
                log(`Connection failed: ${error}`, 'error');
                statusEl.textContent = `Status: Error - ${error.message}`;
            }
        });
        
        /**
         * Cleans up when the device disconnects.
         */
        function onDisconnected() {
            log('Device disconnected.', 'error');
            statusEl.textContent = 'Status: Disconnected';
            bluetoothDevice = null;
            hrCharacteristic = null;
            // Reset UI
            hrDisplay.textContent = '--';
            minHrEl.textContent = '--';
            maxHrEl.textContent = '--';
            avgHrEl.textContent = '--';
            hrHistoryEl.textContent = '--';
        }

        /**
         * Searches for the heart rate service, starting with the standard one
         * and then falling back to a broader search.
         * @param {BluetoothRemoteGATTServer} server - The GATT server instance.
         */
        async function findHeartRateService(server) {
            try {
                // First, try the standard heart rate service
                log('Attempting to find standard Heart Rate service (180d)...');
                const service = await server.getPrimaryService('heart_rate').catch(() => null);

                if (service) {
                    log('Standard Heart Rate service found!', 'success');
                    hrCharacteristic = await service.getCharacteristic('heart_rate_measurement');
                    await startHrNotifications(hrCharacteristic);
                    return;
                }

                // If standard service fails, search all services for a suitable characteristic
                log('Standard service not found. Searching all services for notifying characteristics...');
                statusEl.textContent = 'Status: Searching all services...';
                
                const allServices = await server.getPrimaryServices();
                log(`Found ${allServices.length} services. Inspecting them...`);

                for (const service of allServices) {
                    log(`Inspecting Service: ${service.uuid}`);
                    const characteristics = await service.getCharacteristics();
                    
                    for (const char of characteristics) {
                        // We are looking for any characteristic that can send notifications
                        if (char.properties.notify) {
                            log(`Found NOTIFY characteristic: ${char.uuid}. Subscribing for data...`);
                            // We will start listening to ALL notifying characteristics.
                            // The handleHeartRateData function will figure out which one is correct.
                            await startHrNotifications(char);
                        }
                    }
                }
                log('Finished searching all services. Waiting for data...');
                statusEl.textContent = 'Status: Connected & Listening';

            } catch (error) {
                log(`Error finding service: ${error}`, 'error');
                statusEl.textContent = `Status: Error - ${error.message}`;
            }
        }

        /**
         * Starts notifications for a given characteristic and attaches the event listener.
         * @param {BluetoothRemoteGATTCharacteristic} characteristic
         */
        async function startHrNotifications(characteristic) {
            try {
                characteristic.addEventListener('characteristicvaluechanged', handleHeartRateData);
                await characteristic.startNotifications();
                log(`Started listening to notifications from ${characteristic.uuid}`, 'success');
            } catch (error) {
                log(`Failed to start notifications on ${characteristic.uuid}: ${error.message}`, 'error');
            }
        }

        /**
         * This function is called every time the watch sends data.
         * It tries to parse the heart rate from the raw data.
         * @param {Event} event - The event object from the characteristic.
         */
        function handleHeartRateData(event) {
            const characteristic = event.target;
            const value = characteristic.value;
            const rawData = new Uint8Array(value.buffer);
            
            // Log the raw data from the specific characteristic - THIS IS CRUCIAL FOR DEBUGGING
            log(`Data from [${characteristic.uuid}]: [${rawData.join(', ')}]`, 'data');

            let heartRate = parseHeartRate(value);

            if (heartRate !== null) {
                // We found a valid heart rate! This is likely the correct characteristic.
                log(`Successfully parsed Heart Rate: ${heartRate} bpm`, 'success');
                
                // Update UI elements
                hrDisplay.textContent = heartRate;
                hrDisplay.classList.add('recent-hr');
                hrDisplay.addEventListener('animationend', () => {
                    hrDisplay.classList.remove('recent-hr');
                }, { once: true });


                // Update stats
                hrValues.push(heartRate);
                if (hrValues.length > 20) {
                    hrValues.shift(); // Keep the last 20 readings
                }

                minHr = Math.min(...hrValues);
                maxHr = Math.max(...hrValues);

                // Calculate Exponential Moving Average for a smoother average
                if (smoothedHr === 0) {
                    smoothedHr = heartRate;
                } else {
                    smoothedHr = (heartRate * 0.2) + (smoothedHr * 0.8);
                }

                minHrEl.textContent = minHr;
                maxHrEl.textContent = maxHr;
                avgHrEl.textContent = smoothedHr.toFixed(1);
                hrHistoryEl.textContent = hrValues.slice(-10).join(', ');
            }
        }
        
        /**
         * Tries various methods to parse the heart rate from a DataView object.
         * @param {DataView} value - The data from the Bluetooth characteristic.
         * @returns {number|null} The parsed heart rate or null if not found.
         */
        function parseHeartRate(value) {
            const flags = value.getUint8(0);
            const is16BitFormat = flags & 0x01;
            const rawData = new Uint8Array(value.buffer);

            // Standard Bluetooth Heart Rate Profile
            if (is16BitFormat) {
                // 16-bit heart rate value
                return value.getUint16(1, true); // true for little-endian
            } else {
                // 8-bit heart rate value
                let hr = value.getUint8(1);
                if (hr > 40 && hr < 220) return hr; // Basic validation
            }

            // --- Fallback for Proprietary Formats ---
            // Many devices (like Mi Bands, etc.) send HR in the second byte of a longer array.
            if (rawData.length > 1) {
                let hr = rawData[1];
                if (hr > 40 && hr < 220) {
                    log(`(Fallback) Found potential HR at byte 1: ${hr}`);
                    return hr;
                }
            }
            
            // Another common pattern is the third byte
            if (rawData.length > 2) {
                let hr = rawData[2];
                if (hr > 40 && hr < 220) {
                    log(`(Fallback) Found potential HR at byte 2: ${hr}`);
                    return hr;
                }
            }

            // If all else fails, return null
            return null;
        }

    </script>
</body>
</html>
